<html>
<head>
<link rel='stylesheet' href='https://pyscript.net/latest/pyscript.css'>
<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/89/three.min.js'></script>
<script defer src='https://pyscript.net/latest/pyscript.js'></script>
</head>
<py-env>
  - numpy
</py-env>
<body>		
<py-script>
from pyodide import create_proxy, to_js
from js import THREE, window, Object, performance
import js, pyodide
import numpy as np

# Mouse events
mouse = THREE.Vector2.new()
mousedown = 0

def onMouseMove(event):
	#event.preventDefault()
	mouse.x = (event.clientX / window.innerWidth) * 2 - 1
	mouse.y = -(event.clientY / window.innerHeight) * 2 + 1
	
def onMouseDown(event):
	global mousedown
	mousedown = 1
#	console.log('Mouse down')

def onMouseUp(event):
	global mousedown
	mousedown = 0
#	console.log('Mouse up')

#def onMouseClick(event):
#	event.preventDefault()
#	console.log(event.mousedown)

js.document.addEventListener('mousemove', pyodide.create_proxy(onMouseMove))
js.document.addEventListener('mousedown', pyodide.create_proxy(onMouseDown))
js.document.addEventListener('mouseup', pyodide.create_proxy(onMouseUp))
#js.document.addEventListener('click', pyodide.create_proxy(onMouseClick))


# Forward kinematics for end-effector (in robot coordinate system)
def fkin(x, param):
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	f = np.vstack([
		param.l @ np.cos(L @ x),
		param.l @ np.sin(L @ x)
	]) 
	return f

# Forward kinematics for all joints (in robot coordinate system)
def fkin0(x, param): 
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	f = np.vstack([
		L @ np.diag(param.l) @ np.cos(L @ x),
		L @ np.diag(param.l) @ np.sin(L @ x)
	])
	f = np.hstack([np.zeros([2,1]), f])
	return f

# Jacobian with analytical computation (for single time step)
def Jkin(x, param):
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	J = np.vstack([
		-np.sin(L @ x).T @ np.diag(param.l) @ L,
		 np.cos(L @ x).T @ np.diag(param.l) @ L
	])
	return J

param = lambda: None # Lazy way to define an empty class in python
param.nbVarX = 3 # State space dimension (x1,x2,x3)
param.nbVarF = 3 # Objective function dimension (f1,f2,f3, with f3 as orientation)
param.l = [200, 200, 100] # Robot links lengths

x = np.array([3*np.pi/4, -np.pi/2, -np.pi/4]) # Initial state
#x = np.zeros([3,1]); 
#print(x)

# Webgl scene
#camera = THREE.PerspectiveCamera.new(75, window.innerWidth / window.innerHeight, 0.1, 300);
camera = THREE.OrthographicCamera.new(-window.innerWidth/2, window.innerWidth/2, window.innerHeight/2, -window.innerHeight/2, -500, 500)
camera.position.set(0, 0, 300)
camera.lookAt(0, 0, 0);

scene = THREE.Scene.new()
scene.background = THREE.Color.new("#FFFFFF")

#perms = {"antialias":1, "depth":1}
#perms = Object.fromEntries(to_js(perms))
#renderer = THREE.WebGLRenderer.new(perms)
renderer = THREE.WebGLRenderer.new({"antialias":True})
renderer.shadowMap.enabled = False
renderer.shadowMap.type = THREE.PCFSoftShadowMap
renderer.shadowMap.needsUpdate = True

#renderer.depth = 1
#renderer.antialias = 1
renderer.setSize(window.innerWidth, window.innerHeight)
document.body.appendChild(renderer.domElement)

# Object

#f = fkin0(x, param) #This does not work: be careful!!!!
f = np.zeros([2,4])
fh = np.zeros([2,])
#fh=np.array([200.0, 0])


# World
geometry = THREE.BoxGeometry.new(700, 700, 0.1)
perms = {"color":"#DDDDDD"}
perms = Object.fromEntries(to_js(perms))
bg_material = THREE.MeshBasicMaterial.new(perms)
bg = THREE.Mesh.new(geometry, bg_material)
bg.position.set(0, 0, -0.2)
scene.add(bg)


# Object to reach
perms = {"color":"#FF3399", "size":20}
perms = Object.fromEntries(to_js(perms))
obj_material = THREE.PointsMaterial.new(perms)
#obj_material.color.setRGB(1.0, 0.3, 0.7)
geometry = THREE.Geometry.new()
geometry.vertices.push(THREE.Vector3.new(fh[0], fh[1], 0))
obj = THREE.Points.new(geometry, obj_material)
scene.add(obj)


# Robot
geometry = THREE.Geometry.new()
geometry.vertices.push(THREE.Vector3.new(f[0,0], f[1,0], 2))
geometry.vertices.push(THREE.Vector3.new(f[0,1], f[1,1], 2))
geometry.vertices.push(THREE.Vector3.new(f[0,2], f[1,2], 2))
geometry.vertices.push(THREE.Vector3.new(f[0,3], f[1,3], 2))

perms = {"color":"#777777", "linewidth":8}
perms = Object.fromEntries(to_js(perms))
rob_material = THREE.LineBasicMaterial.new(perms)
rob = THREE.Line.new(geometry, rob_material)
scene.add(rob)
#rob.matrixAutoUpdate = 0
#rob.updateMatrix()


# Articulations
perms = {"color":"#000000", "size":5}
perms = Object.fromEntries(to_js(perms))
j_material = THREE.PointsMaterial.new(perms)

geometry = THREE.Geometry.new()
geometry.vertices.push(THREE.Vector3.new(f[0,0], f[1,0], 3))
j0 = THREE.Points.new(geometry, j_material)
scene.add(j0)

geometry = THREE.Geometry.new()
geometry.vertices.push(THREE.Vector3.new(f[0,1], f[1,1], 3))
j1 = THREE.Points.new(geometry, j_material)
scene.add(j1)

geometry = THREE.Geometry.new()
geometry.vertices.push(THREE.Vector3.new(f[0,2], f[1,2], 3))
j2 = THREE.Points.new(geometry, j_material)
scene.add(j2)

geometry = THREE.Geometry.new()
geometry.vertices.push(THREE.Vector3.new(f[0,3], f[1,3], 3))
j3 = THREE.Points.new(geometry, j_material)
scene.add(j3)



#sprite = THREE.TextureLoader.new() 
#sprite.load('images/disc.png')
##sprite.load("https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/disc.png")
##sprite = THREE.TextureLoader.load('images/disc.png')

#perms = {"size":5, "sizeAttenuation":1, "map":sprite, "alphaTest":0.5, "transparent":1} #, 
#perms = Object.fromEntries(to_js(perms))
#material = THREE.PointsMaterial.new(perms);


raycaster = THREE.Raycaster.new();
raycaster.params.Points.threshold = 100.0;

fh = [200.0, 0]

while True:
#	time = performance.now() * 0.005;
#	camera.position.set(100.0*np.sin(time), 0, 300)
#	camera.lookAt(0, 0, 0);

#	dx = mouse.x * 2;
#	x[2] = (np.random.rand(1)-0.5) * np.pi*2;

#	# FK test
#	x[0] = mouse.x * 4;
#	x[1] = mouse.y * 4;	
#	f = fkin0(x, param);
	
	# IK test
#	fh[0] = 500.0 * mouse.x
#	fh[1] = 500.0 * mouse.y
	J = Jkin(x, param)
	f = fkin0(x, param)
	dx = np.linalg.pinv(J) @ (fh - f[:,-1])	
	x += dx * 5E-1

	# Update webgl rendering
	j0.position.set(f[0,0], f[1,0], 0)
	j1.position.set(f[0,1], f[1,1], 0)
	j2.position.set(f[0,2], f[1,2], 0)
	j3.position.set(f[0,3], f[1,3], 0)
	obj.position.set(fh[0], fh[1], 0)
	
	rob.geometry.vertices[0].set(f[0,0], f[1,0], 0)
	rob.geometry.vertices[1].set(f[0,1], f[1,1], 0)
	rob.geometry.vertices[2].set(f[0,2], f[1,2], 0)
	rob.geometry.vertices[3].set(f[0,3], f[1,3], 0)
	
	rob.updateMatrixWorld()
	rob.updateMatrix()
	rob.geometry.applyMatrix(rob.matrix)
	rob.matrix.identity()
	
	raycaster.setFromCamera(mouse, camera);
#	intersections = raycaster.intersectObjects(scene.children)
#	intersections = raycaster.intersectObject(bg) 
	intersections = raycaster.intersectObject(obj) 
	if mousedown==1 and intersections.length > 0:
		fh[0] = intersections[0].point.x
		fh[1] = intersections[0].point.y
#		console.log(intersections[0].point)		
#		obj.position.set(intersections[0].point.x, intersections[0].point.y, 0)
#		intersections[0].object.material.color.set(0xff0000);


#	# depth tests...
#	bg.updateMatrixWorld()
#	bg.updateMatrix()
#	bg.geometry.applyMatrix(bg.matrix)
#	bg.matrix.identity()
#	
#	camera.updateMatrixWorld()
#	camera.updateMatrix()
##	camera.geometry.applyMatrix(camera.matrix)
##	camera.matrix.identity()
	
	renderer.render(scene, camera)
	await asyncio.sleep(0.02)

</py-script>
</body>
</html>
